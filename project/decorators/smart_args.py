import inspect
import random
import copy


class Evaluated:
    """Class to indicate that the default value of a function argument should be evaluated when called."""

    def __init__(self, func):
        self.func = func


class Isolated:
    """Class to indicate that the default value of a function argument should be a deep copy."""

    pass


def smart_args(positional_support=False):
    """Decorator to handle default argument values in a smart way.

    This decorator allows functions to define default argument values that can
    be evaluated or deep-copied when the function is called. It also provides
    an option to allow or disallow positional arguments.

    Args:
        positional_support (bool): If True, allows positional arguments; otherwise, only keyword arguments are allowed.

    Returns:
        function: The decorated function with enhanced argument handling.
    """

    def decorator(func):
        """Wraps the original function to modify its argument handling."""
        # Get the signature of the function to analyze parameters
        signature = inspect.signature(func)
        parameters = signature.parameters

        def wrapper(*args, **kwargs):
            """Handles the argument processing and invokes the original function."""
            # Check for positional arguments if not supported
            if not positional_support:
                assert (
                    len(args) == 0
                ), "Positional arguments are not allowed. Use named arguments."

            # Create a new dictionary for the default argument values
            new_kwargs = {}
            for i, (name, param) in enumerate(parameters.items()):
                if i < len(args):
                    # If a positional argument is provided, use it
                    new_kwargs[name] = args[i]
                elif name in kwargs:
                    # If the argument is explicitly passed, use it
                    new_kwargs[name] = kwargs[name]
                elif param.default is param.empty:
                    raise ValueError(f"Argument '{name}' is required but not provided.")
                else:
                    # Check for the combination of Evaluated and Isolated
                    if isinstance(param.default, Evaluated) and isinstance(
                        param.default.func, Isolated
                    ):
                        raise ValueError(
                            f"Argument '{name}' cannot have both Evaluated and Isolated as default."
                        )

                    if isinstance(param.default, Evaluated):
                        new_kwargs[name] = param.default.func()
                    elif isinstance(param.default, Isolated):
                        assert (
                            len(args) <= i
                        ), f"Argument '{name}' must be provided as a keyword argument."
                        new_kwargs[name] = copy.deepcopy(kwargs.get(name, {}))
                    else:
                        # Simply take the default value
                        new_kwargs[name] = param.default

            return func(**new_kwargs)

        return wrapper

    return decorator


# Examples of using the smart_args decorator
@smart_args()
def check_isolation(*, d=Isolated()):
    """Check isolation by modifying a dictionary passed as an argument.

    Args:
        d (dict): A dictionary that will be modified. Default is an isolated copy.

    Returns:
        dict: The modified dictionary.
    """
    d["a"] = 0
    return d


def get_random_number():
    """Generates a random number between 0 and 100.

    Returns:
        int: A random number between 0 and 100.
    """
    random.seed(0)
    return random.randint(0, 100)


@smart_args()
def check_evaluation(*, x=get_random_number(), y=Evaluated(get_random_number)):
    """Check the evaluation of default values.

    Args:
        x (int): A random number generated by default.
        y (int): A value that is evaluated when the function is called.

    Returns:
        tuple: The values of x and y.
    """
    return x, y  # Return the values for testing


# Example with positional arguments enabled
@smart_args(positional_support=True)
def example_with_positional(a=1, b=2):
    """An example function that accepts positional arguments.

    Args:
        a (int): The first positional argument. Default is 1.
        b (int): The second positional argument. Default is 2.

    Returns:
        int: The sum of a and b.
    """
    return a + b
